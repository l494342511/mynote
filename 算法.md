# 算法

## 1. 动态规划问题

### 1.1 背包问题

#### 1.1.1 简单背包问题

**问题：**有若干个物品，物品有各自的体积和价值。我们有一个背包，背包有体积上限。如何选择物品放入背包，使得到的价值最大，且不超过背包的体积上限。

##### **动态规划的核心是填表**

| i\v  |  0   |  1   |  2   |  3   |  4   |  5   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  0   |  0   |  0   |  0   |
|  2   |  0   |      |      |      |      |      |
|  3   |  0   |      |      |      |      |      |
|  4   |  0   |      |      |      |      |      |

##### **表格的意义**

表格的行指背包的体积，列坐标是指可选的物品是前i个，注意物品按体积的大小从小到大排列，从小的物品开始填表

表格中的单元格的意义是，可选的物品是前i个时、背包体积是v时，采取最佳决策可以获得的价值

##### **填表**

填表的顺序是从左到右从上到下，一行一行填，并且从小的物品开始填表

当可选物品只有一个时，显然当背包体积小于该物品体积时，可得到的价值都是0，因此填进0。当背包体积大于它时，最优价值就是该物品的价值。

当有两个物品可选时，显然在背包体积大于第二件物品前，表中内容都与第一排相同。当背包体积能够放下第二个背包时，此时可以做两种选择：1. 放物品2  2. 不妨物品2；很明显这里只要比较一下两个物品的价值就行，当背包体积满足两个物品时，表中填入两者的价值之和。

**但是当可选物品有三个及以上时，并不能做这样简单的比较**。比如当可选物品有三个，背包体积同时放入其中任一两物品时，如果做简单的比较，就需要做三次排列组合，不仅复杂，而且也失去了填表的意义。

因此此时更优的做法是：比较1. 放物品3 2. 不放物品3两个策略的价值。

1. 不放物品3的策略就是i=2，v不变时的策略，因此就是该单元格上方的单元格的内容。
2. **而计算放物品3策略的价值，可以先将物品3放入，此时背包体积便减去物品3的体积，然后在表中寻找背包体积等于剩余体积，可选物品为物品1、2的策略的价值，最后整个策略的价值再加上物品3的价值就好。这样做就将排列组合转换为比较两个单元格的大小。**

**总结：填表的目的就是让已经做过的策略不再做重复计算，减少计算资源的浪费**

### 1.2 投资分配问题

**问题：**假设我们资金有x万元，有n个投资项目供我们选择，在每个项目上投资的资金都会影响该项目的收益，且每个项目受资金多少的影响幅度也不同，如下表：

| 投资资金\项目 | 1    | 2    | 3    | 4    |
| ------------- | ---- | ---- | ---- | ---- |
| 1             | 0    | 10   | 12   | 20   |
| 2             | 5    | 13   | 20   | 21   |
| 3             | 8    | 15   | 28   | 22   |
| 4             | 12   | 17   | 32   | 24   |
| 5             | 13   | 18   | 42   | 26   |

**解决思路：**

与背包问题类似，自底向上填表，表如：

|      | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    |      |      |      |      |      |
| 2    |      |      |      |      |      |
| 3    |      |      |      |      |      |
| 4    |      |      |      |      |      |

纵坐标表示仅考虑前n个项目，横坐标表示我们所拥有的资金，则表格中的单元格的意义为：总资金为x时，仅考虑前y个项目能获得的最大收益

当计算(x, y)单元格时，此时根据投入在第y个项目的资金，可以得到几种不同的策略，如若在第y个项目投入2万元时，此时剩余资金为x-2，剩余未考虑项目为前y-1个项目，则此时策略的最大收益为y(2)+(x-2, y-1)，(x-2, y-1)已经填好可以直接获取

**回溯表：**记录在单元格(x, y)对y项目投入的资金

### 1.3 编辑距离计算

**问题：**计算一个字符串变为另一个字符串需要的最少编辑次数，可进行的编辑操作有：删除，插入，替换。

**解决思路：**

**表格：**

|      | A    | B    | C    | D    | E    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    |      |      |      |      |      |
| C    |      |      |      |      |      |
| E    |      |      |      |      |      |
| D    |      |      |      |      |      |
| F    |      |      |      |      |      |

**单元格**(x, y)表示源字符串前x个字符与目标字符串前y个字符间的编辑距离

当我们从两个字符串最后一位字符（假设对应单元格(x, y)）开始比较，此时有两种情况：

1. 最后一位字符相同：相同时，针对该字符不需要做任何修改，因此此时(x, y) = (x-1, y-1)

2. 最后一位字符不同：字符不同时，可做三种修改

   1. 删除该字符

      删除该字符后，源字符串剩余字符有y-1个，而目标字符串剩余字符仍有x个，因此此时(x, y) = (x, y-1)+1

   2. 插入新字符

      插入新字符，源字符串新增字符与目标字符串最后第一位字符相同，因此目标剩余x-1个字符，源字符串剩余y个字符，因此此时(x, y) = (x-1, y)+1

   3. 替换该字符

      替换字符后，源字符剩余y-1个字符，目标字符串剩余x-1个字符，此时(x, y) = (x-1, y-1)+1

   因此字符不同时 (x, y) = max((x, y-1)，(x-1, y)，(x-1, y-1))+1

根据递推关系，我们很容易能够自底向上填好所有的单元格，从而计算编辑距离

**回溯表：**单元格记录进行的操作，或者回溯的方向

## 1.4 求最长递增子序列问题

**问题描述：**求一个数字序列的最长子序列，且该序列中的数字是递增的

**解决思路：**设L(i)为以ai为最后一位的子序列的长度，则L(i)=1+L(j)，L(j)为以ai为最后一位的子序列的长度，这里的aj是ai前第一个比ai小的数。从而我们得到了求得最长子序列的长度的公式：L = maxL(i)

## 1.5 生产线分配问题

**问题描述：**一个产品生产全过程需要k个环节，已有两条生产线，每条生产线都能处理这k个环节，但是处理的时间不同，在生产时，我们能在一个生产环节完成后将产品迁移到另一条生产线上，但是迁移也会耗费时间，同时同一条生产线上也有运输时间,如何规划生产路线使生产耗费时间最少。

**解题思路：**设在生产线1上第n个环节的耗费时间为C1n，在进行第n个环节前将产品从1迁移到2的耗费时间为M12n，设到达生产线1第n个环节前的最少耗费时间为T1n，所以可得 T1n = min(T1n-1 + M11n, T2n-1+M21n)

## 1.6 钢板分割问题

**问题描述：**不同长度的钢板的价格不同，如何切割一块钢板使其卖出的价格最多

**解题思路：**假设钢板总长为L，切割后最后一段钢板的长度为a，假设长度为L的钢板通过切割获得的最大价值为P(L)，长度为L的钢板的单价为p(L)，可得 P(L) = P(L-a) + p(a)

## 1.7 求路径数问题

**问题描述：**一个(x, y)的网格，小明从左下角的点出发，到达右上角的点，途中只能向右或者向上移动，求有多少种走法

**解题思路：**设到达点(m, n)的路径数为 F(m, n)，则F(m, n) = F(m, n-1) + F(m-1, n)，即到达(m, n)的路径数可以由它左侧和下侧的点得到，因此利用动态规划求一点的路径数，必须记录了左侧和下侧的点的路径，因此表格对于网格中的点，并且从左到右从下到上记录每一点的路径数

## 1.8 谷歌面试题：扔鸡蛋

**问题描述：**一栋楼有一百层，其中有一层为临界楼，在低于临界楼以下的楼层朝下扔鸡蛋都不会碎，从超过临界层的楼层朝下扔鸡蛋则会碎。在只有2个鸡蛋的情况下，设计一种最快找到临界层的方法

**数学分析：**

1. 假设第一次从K层扔鸡蛋，此时面对两种情况：
   1. 鸡蛋碎了：说明临界层在K层以下，但此时鸡蛋仅剩1个，因此我们只能从1层向上一层一层尝试，因此此时最坏的尝试次数为K；
   2. 鸡蛋没碎：说明临界层在K层以上，此时鸡蛋仍然剩2个，因此要向上尝试，但是如何选择一个合适的楼数进行尝试有三种情况：
      1. 在上一次的层数上增加K，即选择2K层，如果此时鸡蛋碎了，要从K+1层向上开始尝试，此时最坏的尝试次数为K+1，比第一次碎了的最坏次数还差，如果鸡蛋没碎还要再向上尝试，最坏次数会更多，因此这种策略不好；
      2. 增加N>K层，很明显比第一种策略还更差；
      3. 增加层数N小于K层，我们发现这样的策略使得最坏次数都不会超过第一次鸡蛋碎的时候的最坏次数；因此此时我们要考虑的就是要使扔鸡蛋的次数最少，很明显，当N越大时，扔鸡蛋的次数越少，因此取N=K-1
2. 当N取为K-1时，最好的情况就是鸡蛋一直扔到了100层，此时等式：n+(n-1)+(n-2)+…+1=100=n(n+1)/2；成立，可以得到n=14;

**动态规划方法：**

1. 我们设dp\[i][j]表示：当鸡蛋数为i，楼层数为j时，最好的方法得到的最坏尝试次数；
2. 假设我们第一次尝试的楼层为k，此时最坏尝试次数应该为DP\[i][j] = max(dp\[i-1][k-1], dp\[i][i-k])
3. 当我们遍历所有可能的k后，此时得到的最小的DP\[i][j]就是dp\[i][j]的值

**代码实现：**

```java
public class ThrowEggs {

    public static int[][] init(int I,int J){
        int[][] dp = new int[I+1][J+1];
        for(int i=0;i<=I;i++){
            for(int j=0;j<=J;j++){
                dp[i][j] = 99999;
            }
        }
        for(int i=1;i<=I;i++){
            dp[i][1] = 1;
            dp[i][0] = 0;
        }
        for(int j=1;j<=J;j++){
            dp[1][j] = j;
        }
        return dp;
    }

    public static int TryThrow(int eggNum, int floorNum){
        int[][] dp = init(eggNum, floorNum);
        for(int i=2;i<=eggNum;i++){
            for(int j=2;j<=floorNum;j++){
                for(int k=1;k<j;k++){
                    dp[i][j] = Math.min(dp[i][j],Math.max(dp[i-1][k-1]+1,dp[i][j-k]+1));
                }
            }
        }
        return dp[eggNum][floorNum];
    }

    public static void main(String[] args) {
        System.out.println(TryThrow(2,100));
    }
}
```

