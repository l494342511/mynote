# 数据结构与算法

## 1. 什么是数据结构

### 1.1 递归与循环

```java
//使用循环
public static void PrintNWithFor(int N){
    for(int i=1;i<N;i++){
        System.out.println(i);
    }
}

//使用递归
public static void PrintNWithRec(int N){
    if(N>1){
        PrintNWithRec(N-1);
        System.out.println(N);
    }
}
```

递归程序在运算时，返回是从里往外的，也就是说如果使用递归程序打印十万次，最多需要分配十万倍的空间，只有当最内层的程序得出结果后，才会由内往外释放内存，因此递归占用的空间十分恐怖

### 1.2 评价算法好坏的指标

**空间复杂度S(n)：**根据算法写成的程序在执行时**占用存储空间**的长度，空间复杂度过高的算法可能会使使用的内存超限。

**时间复杂度T(n)：**根据算法写成的程序在执行时**耗费时间**的长度。一般分为最坏复杂度和平均复杂度，更关注最坏复杂度。

**计算时间复杂度：**加减法很快，基本计算乘除法的次数

**复杂度的表示：**

	1. **T(n)=O(f(n))**表示存在常数C>0，n0>0使得当n>n0时有T(n)≤C·f(n)
 	2. **T(n)=Ω(f(n))**表示存在常数C>0，n0>0使得当n>n0时有T(n)≥C·f(n)
 	3. **T(n)=Θ(f(n))**表示同时有**T(n)=O(f(n))**和**T(n)=Ω(f(n))**

![image-20210314145039619](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20210314145039619.png)

### 1.3 实例

**问题：求最大子列和**

**算法1：直接套三次循环遍历：**时间复杂度是N^3

**算法2：二分迭代法：**对数组进行二分，求二分后的子列的大小关系以及跨中点的最大子列和的大小关系，对子列再进行二分迭代，时间复杂度是NlogN

```java
 //计算最大子列
    public static double getMaxSon(double[] a){
        double maxSum = 0;
        int leng = a.length;


        if(leng==2){//如果长度为2，可以直接得出其最大子列
            maxSum = (a[0]>a[1]?a[0]:a[1])>(a[0]+a[1])?(a[0]>a[1]?a[0]:a[1]):(a[0]+a[1]);
        }else if(leng==1){
            maxSum = a[0];
        }else{//如果长度大于2，需要进行递归
            int lengA = (int)(leng/2);
            int lengB = leng-lengA;
            double[] A = Arrays.copyOfRange(a,0,lengA);
            double[] B = Arrays.copyOfRange(a,lengA,leng);
            double maxA = getMaxSon(A);
            double maxB = getMaxSon(B);
            double maxC = getMaxC(A,1)+getMaxC(B,0);
            maxSum = (maxA>maxB?maxA:maxB)>maxC?(maxA>maxB?maxA:maxB):maxC;
        }

        return maxSum;
    }


    public static double getMaxC(double[] a,int c){
        double max = 0;
        double sum = 0;
        if(c==0){//向右
            for(double num:a){
                sum+=num;
                if(sum>max){
                    max=sum;
                }
            }
        }else{
            for(int i=a.length-1;i>=0;i--){
                sum+=a[i];
                if(sum>max){
                    max=sum;
                }
            }
        }
        return max;
    }
```

**算法3：在线求解法：**从一端开始遍历，依次向后加，当和小于0时舍弃当前sum，再从新的起点开始遍历，时间复杂度是O(N)

```
public static double countSonArr(double[] a){
    double maxSum = 0;
    double sum = 0;
    for(int i=0;i<a.length;i++){
        sum+=a[i];
        if(sum>maxSum){
            maxSum=sum;
        }
        if(sum<0){
            sum=0;
        }
    }

    return maxSum;
}
```

## 2. 线性结构

### 2.1 线性表及其表示

1. 数组
2. 链表

### 2.2 广义表

**多重链表**

![image-20210314204520692](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20210314204520692.png)

多重链表中第i行的head和第i列的head实际上是同一个节点，可以看到在图中，第i行的head左指针域未利用，第i列的右指针域未利用，因此为减少空间的浪费，用第i个head的左指针指向第i列，用第i个head的右指针指向第i行，因此是同一个节点。

### 2.3 堆栈(Stack)

**后入先出原则(LIFO,last in first out)**

**运用例子：**中缀表示转换未后缀表达式

从左到右读取中缀表达式中的每个对象，分以下几个情况处理：

1. 运算数：直接输出
2. 运算符：如果比栈顶的运算符优先级高，则入栈；如果优先级低，则先将堆栈里的运算符出栈，直至栈顶运算符的优先级比他低为止；
3. 左括号：直接入栈
4. 右括号：将栈顶运算符出栈，直到遇到左括号，出栈不输出
5. 若各对象处理完毕，则将堆栈中所有运算符依次输出

**应用：**

1. 函数调用及递归实现
2. 深度优先搜索
3. 回溯算法

### 2.4 队列(Queue)

**先入先出原则(FIFO,FIRST IN FIRST ON)**

##  3. 树

### **3.1 树的定义**

**树：**由n个结点构成的有限集合

**根(r,Root)：**最顶端的结点，只有一个，其余结点都是他的子树，必须是由上而下，同层之间没有联系，并且一个结点只有一个父结点，有一个N结点的树由n-1条边

**结点的度：**结点的**子树个数**

**树的度：**树的所有结点中最大的度数

**叶结点：**度为0的结点

**父结点：**有子树的结点是其子树的根节点的父结点

**子结点：**

**兄弟结点：**具有同一父节点的各结点相互为兄弟结点

**路径和路径长度：**路径包含边的个数为路径的长度

**祖先结点：**

**子孙结点：**

**结点的层次：**根节点在第一层，其他都是在其父结点的层次上加1

**树的深度：**最大结点层次

### 3.2 二叉树

**定义：**每个结点的度都为2，有左子树和右子树

**完全二叉树：**所有结点是按从上至下、从左到右的顺序进行编号

**按大小构造完全二叉树：**左孩子是父结点的2倍，右孩子是父结点的2倍+1，缺点：若是不完全二叉树用该方法构造，**会造成空间浪费**

### 3.3 二叉树的遍历

#### 3.3.1 遍历方法

1. **先序遍历**

   先访问**根节点**；

   再访问**左子树**；

   再访问**右子树**；

2. **中序遍历**

   先访问**左子树**；

   再访问**根节点**；

   再访问**右子树**；

3. **后序遍历**

   先访问**左子树**；

   再访问**右子树**；

   再访问**根节点**；

![image-20210316105226368](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20210316105226368.png)

**对于这个树：**

**先序遍历：**A B D F E C G H I

**中序遍历：**D B E F A G H C I

**后序遍历：**D E F B H G I C A

#### 3.3.2 遍历的实现

**递归实现：**

```
先序遍历方法(结点):
	if(结点不为null):
        输出结点值
        先序遍历方法(左孩子结点)
        先序遍历方法(右孩子结点)
```

**非递归方法实现（使用堆栈）：**

```
中序遍历方法：
	从根节点出发;
	while(当前结点不为null或栈不空){
		while(当前结点不为null){
            当前结点入栈;
            指向当前结点的左孩子结点;
        }
        if(堆栈不为空){
            结点出栈并输出;
            指向该结点的右孩子结点;
        }
	}
```

**层序遍历方法实现（使用队列）：**

```
层序遍历方法:
	从根结点出发;
	根结点入队;
	while(队列不为空)}{
		从队列中取出一个元素;
		访问该元素;
		将该结点的左右孩子依次入队;
	}
```

### 3.4 二叉搜索树

**定义：**

1. 左子树的所有值都比根节点小
2. 右子树的所有值都比根节点大

### 3.5 平衡二叉树

**定义：**任一结点的左子树的深度与右子树的深度差不超过1

**平衡二叉树的调整：**

**破坏者：**当插入一个结点并破坏了平衡，则称其为破坏者

**被破坏者：**被破坏的结点

**旋转：**破坏点的父结点和被破坏点和他们中间的结点做旋转，

**右旋转（RR旋转）：**